<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="MYSQL架构图 Server层 包括 连接器, 查询缓存， 分析器， 优化器， 执行器 存储引擎负责数据的存储和提取, 其架构模式是插件式的 连接器wait_timeout 控制 如果客户端太长时间没动静， 连接器断开。 默认是8小时 长连接:  如果客户端持续有请求， 则一直使用同一个连接  因为MySQL在执行过程中临时使用的内存是管理在连接对象上的， 所以如果长链接积累下来， 可能导致内存">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql知识梳理">
<meta property="og:url" content="https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/index.html">
<meta property="og:site_name" content="StrBlog">
<meta property="og:description" content="MYSQL架构图 Server层 包括 连接器, 查询缓存， 分析器， 优化器， 执行器 存储引擎负责数据的存储和提取, 其架构模式是插件式的 连接器wait_timeout 控制 如果客户端太长时间没动静， 连接器断开。 默认是8小时 长连接:  如果客户端持续有请求， 则一直使用同一个连接  因为MySQL在执行过程中临时使用的内存是管理在连接对象上的， 所以如果长链接积累下来， 可能导致内存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:/Documents/Pictures/image-20210305084954104.png">
<meta property="og:image" content="https://i.loli.net/2021/03/05/tAvZO7kNDpE14MV.png">
<meta property="og:image" content="c:/Users/Administrator/Desktop/dec177a2d927fc5944e02def96f5a8d.png">
<meta property="article:published_time" content="2021-03-05T22:13:53.000Z">
<meta property="article:modified_time" content="2021-03-05T15:34:19.709Z">
<meta property="article:author" content="Str">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/Documents/Pictures/image-20210305084954104.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/app-touch-icon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Mysql知识梳理</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/projects_url">项目</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&text=Mysql知识梳理"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&is_video=false&description=Mysql知识梳理"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Mysql知识梳理&body=Check out this article: https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&name=Mysql知识梳理&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&t=Mysql知识梳理"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MYSQL%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">MYSQL架构图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">连接器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.0.2.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">优化器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">执行器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">更新语句执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97-redo-log"><span class="toc-number">2.1.</span> <span class="toc-text">重要的日志模块: redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97-binlog"><span class="toc-number">2.2.</span> <span class="toc-text">重要的日志模块 binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E8%B7%9F-binlog-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">redo log 跟 binlog 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">MySQL 隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">事务隔离的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.1.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.2.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A-%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">4.3.</span> <span class="toc-text">日志系统： 一条SQL更新语句是如何执行的?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql-%E6%9B%B4%E6%96%B0%E7%94%A8%E5%88%B0%E4%BA%86WAL%E6%8A%80%E6%9C%AF-write-Ahead-Logiing-%E5%AE%83%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E6%98%AF%E5%85%88%E5%86%99%E6%97%A5%E5%BF%97%EF%BC%8C-%E5%86%8D%E5%86%99%E7%A3%81%E7%9B%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">Mysql  更新用到了WAL技术(write-Ahead Logiing) , 它的关键点是先写日志， 再写磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="toc-number">4.3.2.</span> <span class="toc-text">redo log(重做日志)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97"><span class="toc-number">4.3.3.</span> <span class="toc-text">binlog(归档日志)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">提交过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">两阶段提交</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID-%E9%9A%94%E7%A6%BB%E6%80%A7-I"><span class="toc-number">4.4.</span> <span class="toc-text">ACID 隔离性(I)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%A6%81%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9"><span class="toc-number">4.5.</span> <span class="toc-text">普通索引和唯一索引要怎么选择?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-MySQL-%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.</span> <span class="toc-text">10 MySQL 选错索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%89%AB%E6%8F%8F%E8%A1%8C%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">修复扫描行异常：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.1.</span> <span class="toc-text">11. 字符串加索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-MySQL-%E8%84%8F%E9%A1%B5"><span class="toc-number">4.7.</span> <span class="toc-text">12. MySQL 脏页</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5%E4%BC%9A%E5%88%B7%E6%96%B0%E8%84%8F%E9%A1%B5"><span class="toc-number">4.7.0.1.</span> <span class="toc-text">四种情况会刷新脏页</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Mysql知识梳理
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Str</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-03-05T22:13:53.000Z" itemprop="datePublished">2021-03-05</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Mysql/" rel="tag">Mysql</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="MYSQL架构图"><a href="#MYSQL架构图" class="headerlink" title="MYSQL架构图"></a>MYSQL架构图</h2><p><img src="D:\Documents\Pictures\image-20210305084954104.png" alt="image-20210305084954104"></p>
<p>Server层 包括 连接器, 查询缓存， 分析器， 优化器， 执行器</p>
<p>存储引擎负责数据的存储和提取, 其架构模式是插件式的</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>wait_timeout 控制 如果客户端太长时间没动静， 连接器断开。 默认是8小时</p>
<p>长连接:  如果客户端持续有请求， 则一直使用同一个连接 </p>
<p>因为MySQL在执行过程中临时使用的内存是管理在连接对象上的， 所以如果长链接积累下来， 可能导致内存占用太大。 故有两种方案</p>
<ol>
<li>定期断开长连接</li>
<li>5.7及以上 ，每次执行一个比较大的操作后， 通过执行mysql_reset_connection 来重新初始化连接资源</li>
</ol>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>MySQL里面存在一个参数  query_cache_type 设置成 DEMAND ， 这样对于默认的SQL语句都不使用查询缓存， 而对于你确定要使用查询缓存的语句， 可以用SQL_CACHE 显示指定 . 8.0 之后 删除了 查询缓存 功能</p>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>词法分析  -  语法分析 </p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>决定使用索引的情况， </p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>判断权限 -  调用引擎接口, 执行</p>
<hr>
<h2 id="更新语句执行过程"><a href="#更新语句执行过程" class="headerlink" title="更新语句执行过程"></a>更新语句执行过程</h2><p>更新流程涉及两个重要的日志模块， redo log(重做日志)  和 binlog(归档日志)</p>
<h3 id="重要的日志模块-redo-log"><a href="#重要的日志模块-redo-log" class="headerlink" title="重要的日志模块: redo log"></a>重要的日志模块: redo log</h3><p>WAL(write ahead logging) :  先写日志， 再写磁盘</p>
<p>当一条记录要更新的时候， InnoDB 引擎先把记录写到redo log(粉板) 里， 并更新内存。 </p>
<p>InnoDB 的 redo log 是固定大小的</p>
<p><img src="https://i.loli.net/2021/03/05/tAvZO7kNDpE14MV.png" alt="1601614908387_.pic_hd.jpg"></p>
<p>write pos 是当前记录的位置， 一边写一边后移， 写到 3 号文件末尾就回到0号文件开头</p>
<p>checkpoint 是当前要擦除的位置， 也是往后推移并且循环的， 擦除记录之前要把记录更新到数据文件</p>
<p>write pos 和   checkpoint 之间的还空着的部分， 可以记录新的操作， 如果write pos 追上了 checkpoint 表示 “粉板” 满了，这时候不能再执行新的更新， 需要先擦掉一些记录， 把 checkpoint 推进一下</p>
<h3 id="重要的日志模块-binlog"><a href="#重要的日志模块-binlog" class="headerlink" title="重要的日志模块 binlog"></a>重要的日志模块 binlog</h3><p>redo log 是 InnoDB 独有的日志， Mysql 的 Server 层也有自己的日志 binlog(归档日志)</p>
<h3 id="redo-log-跟-binlog-区别"><a href="#redo-log-跟-binlog-区别" class="headerlink" title="redo log 跟 binlog 区别"></a>redo log 跟 binlog 区别</h3><ol>
<li>redo log 是InnoDB 引擎独有的， binlog 是MySQL 的Server层实现的， 所有引擎都可以使用</li>
<li>redo log 是物理日志， 记录的是”在某个数据页上做了什么修改”, binlog 是逻辑日志， 记录的是这个语句的原始逻辑， 比如： “给ID= 2这一行的c 字段加1”</li>
<li>redo log 是循环写的， 空间会用完， binlog 是可以追加写的</li>
<li>redo log 的大小是固定的， 日志上的记录修改落盘后， 日志会被覆盖掉， 无法用于数据回滚/数据恢复等操作</li>
</ol>
<h2 id="MySQL-隔离级别"><a href="#MySQL-隔离级别" class="headerlink" title="MySQL 隔离级别"></a>MySQL 隔离级别</h2><ol>
<li>读未提交: 一个事务还没有提交的时候，它做的变更就被别的事务看到</li>
<li>读提交: 一个事务提交之后, 它做的变更才会被其他事务看到 </li>
<li>可重复读: 一个事务执行过程中看到的数据, 总是跟这个事务在启动时看到的数据是一致的</li>
<li>串行化: 对同一行数据, “写” 会加 “写锁”, “读”会加”读锁”。</li>
</ol>
<hr>
<h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>可重读读</p>
<ol>
<li>每条记录更新的时候都会用时记录一条回滚操作。 记录上的最新值，通过回滚操作，都可以得到前一个状态的值</li>
<li>当不同时刻启动的事务会有不同的read-view. 同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制(MVCC)</li>
<li>回滚日志会在 系统里面没有比这个回滚日志更早的read-view 的时候删除</li>
</ol>
<hr>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul>
<li>分类</li>
</ul>
<ol>
<li><p>全局锁</p>
</li>
<li><p>表级锁</p>
</li>
<li><p>行锁</p>
<ul>
<li><p>两阶段锁</p>
</li>
<li><p>在InnoDB事务中, 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放, 而是等到事务结束时才释放。 所以要尽可能的将影响并发度的锁往后放</p>
</li>
<li><p>死锁:<br>当并发系统中不同线程出现循环资源依赖, 涉及的线程都在等待别的线程资源释放时， 就会导致这几个线程进入无限等待的过程。 称为死锁<br>解决办法：</p>
<ul>
<li>设置参数 innodb_lock_wait_timeout<br>影响正常业务</li>
<li>死锁检测, 主动回滚死锁链条中的某一个事务。<br>将 innodb_deadlock_detect 设置为0 . 表示开启这个逻辑<br>检测带来 的成本也会造成死锁</li>
</ul>
<p>为了解决 热点行更新 导致的性能问题</p>
<ul>
<li>关闭检测</li>
<li>修改源码, 对应相同行的更新， 在进入引擎之前排队</li>
<li>业务拆分<br>原理:    控制访问相同资源的并发事务量</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>一个数据版本, 对于一个事务视图来说, 除了自己的更新总是可见以外，有三种情况</p>
<ul>
<li><p>版本未提交， 不可见</p>
</li>
<li><p>版本已提交， 但是在视图创建后提交的， 不可见</p>
</li>
<li><p>版本已提交， 而且是在视图创建前提交的。 可见</p>
</li>
</ul>
<hr>
<h3 id="日志系统：-一条SQL更新语句是如何执行的"><a href="#日志系统：-一条SQL更新语句是如何执行的" class="headerlink" title="日志系统： 一条SQL更新语句是如何执行的?"></a>日志系统： 一条SQL更新语句是如何执行的?</h3><h4 id="Mysql-更新用到了WAL技术-write-Ahead-Logiing-它的关键点是先写日志，-再写磁盘"><a href="#Mysql-更新用到了WAL技术-write-Ahead-Logiing-它的关键点是先写日志，-再写磁盘" class="headerlink" title="Mysql  更新用到了WAL技术(write-Ahead Logiing) , 它的关键点是先写日志， 再写磁盘"></a>Mysql  更新用到了WAL技术(write-Ahead Logiing) , 它的关键点是先写日志， 再写磁盘</h4><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><p><img src="C:\Users\Administrator\Desktop\dec177a2d927fc5944e02def96f5a8d.png" alt="dec177a2d927fc5944e02def96f5a8d"></p>
<p>redo log 是在 引擎层</p>
<ul>
<li><p>write pos 是当前记录的位置， 一边写一边后移， 写到3号文件末尾后就回到0号文件开头</p>
</li>
<li><p>checkpoint 是当前要擦除的位置。也是往后推移并且循环的。 擦除记录之间要把记录更新到数据文件</p>
</li>
</ul>
<p>他们之间空着的部分，可以用来记录新的操作。如果 writepos 追上了checkpoint 表示 rodo log 已经满了， 需要擦除并写入磁盘</p>
<p>这种即使数据库发送异常重启，也不会丢失之前记录的能力就是 crash-log</p>
<h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h4><p>binlog 是在 Server 层</p>
<p>redo log 和 binlog 的区别</p>
<ul>
<li>redo log 是 InnoDB引擎独有的,  binlog 是 MySQL的Server层实现的，所有引擎都可以使用</li>
<li>redo log 是物理日志, 记录的是 “某个数据页上做了什么修改”, binlog 是逻辑日志， 记录的是这个语句的原始逻辑 如”给id = 2 的这一行的c字段加1”</li>
<li>redo log 是循环写的，空间固定会用完， binlog 是可以追加写入的， 追加写的意思是写到一定大小后会切换到下一个， 并不会覆盖以前的日志</li>
</ul>
<h5 id="提交过程"><a href="#提交过程" class="headerlink" title="提交过程"></a>提交过程</h5><p>![43338e1a2cbe63cea2fef10ab6b4bbb](C:\Users\ADMINI~1\AppData\Local\Temp\WeChat Files\43338e1a2cbe63cea2fef10ab6b4bbb.png)</p>
<p>redo log 拆成了两个步骤 : 1. prepare  和 commit 。 这就是两阶段提交</p>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>如果不是两阶段提交会有问题</p>
<p>假设 redo log  和 binlog  是两个独立步骤</p>
<pre><code>1. 先写  redo log 后写 binlog 。 如果在 redolog 写完，binlog 未写完的时候  crash 了。 那么在用 binlog 恢复的时候就会存在 临时库少了这一次结果， 造成数据缺失 
2. 先写 binlog 后写 redo log 。 此时 crash 的话， 因为 redo log 未提交， 所以使用binlog  恢复的时候，就默认任务此时已经提交了， 造成数据不一致</code></pre>
<p>相关参数</p>
<ol>
<li>innodb_flush_log_at_trx_commit:  设置为1, 表示每次事务的 redolog 都直接持久化到磁盘(这里值的是 redolog 日志本身罗盘), 保证mysql 重启后数据不丢失</li>
<li>sync_binlog: 设置为1, 表示每次事务的binlog 都直接持久化磁盘 (这里值的是 binlog 日志本身落盘),  保证mysql 重启后binlog 记录是完整的</li>
<li>max_binlog_size : 设置每个binlog 文件的大小</li>
</ol>
<hr>
<h3 id="ACID-隔离性-I"><a href="#ACID-隔离性-I" class="headerlink" title="ACID 隔离性(I)"></a>ACID 隔离性(I)</h3><p>四种隔离机制</p>
<ol>
<li>读未提交</li>
<li>读提交</li>
<li>可重复读</li>
<li>串行化</li>
</ol>
<p>在实现上， 数据库里面会创建一个视图， 访问的时候以视图的逻辑结果为准。</p>
<p>在 “读未提交” 的时候 ， 没有视图概念， 直接返回记录上的最新值</p>
<p>在 “读提交” 的时候,  是在每个SQL语句开始执行的时候创建的</p>
<p>在”可重复读” 的时候， 视图是在事务启动时创建的， 整个事务存在期间都用这个视图</p>
<p>在 “串行化” 的时候， 直接用加锁来避免并发执行</p>
<hr>
<h3 id="普通索引和唯一索引要怎么选择"><a href="#普通索引和唯一索引要怎么选择" class="headerlink" title="普通索引和唯一索引要怎么选择?"></a>普通索引和唯一索引要怎么选择?</h3><p>change buffer</p>
<ul>
<li> 当需要更新数据之前， 如果数据页在内存中就直接更新, 如果不在， 会缓冲在changer buffer 中下次查询需要访问这个数据页时候， 就将数据页读入到内存， 然后执行change buffer 中与这个页有关的操作</li>
<li> change buffer 实际是哪个是可以持久化的数据。也就是 change buffer 在内存中有拷贝， 也会被写入磁盘上</li>
</ul>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程叫merge</p>
<p>对应唯一索引来说， 所有的更新操作都需要判断是否违反了唯一约束。需要将数据页读入到内存，也就没有必要使用change buffer 了</p>
<p>只有普通索引才可以使用 change buffer</p>
<p>chaner buffer 使用的是 buffer pool 中的内存。change_buffer 的内存 ，可以用innodb_change_buffer_max_size 来动态设置</p>
<p>插入语句的过程</p>
<ol>
<li>记录要更新的目标页在内存中<br>普通索引： 找到对应值, 插入<br>唯一索引： 找到对应值， 判断到没有冲突， 插入</li>
<li>记录要更新的目标页不在内存中<br>普通索引： 将更新记录在change buffer , 语句结束<br>唯一索引： 将数据页读入到内存(耗性能)， 判断没有冲突的情况， 则插入</li>
</ol>
<p>redo log 主要是节省随机写磁盘的IO消耗， change buffer 主要节省的是 随机读磁盘IO消耗</p>
<hr>
<h3 id="10-MySQL-选错索引"><a href="#10-MySQL-选错索引" class="headerlink" title="10 MySQL 选错索引"></a>10 MySQL 选错索引</h3><p>优化器逻辑<br>优化器会根据扫描行数, 是否使用临时表， 是否排序等因素进行综合判断</p>
<p>优化器是根据统计信息来估算记录数，统计信息就是索引的区分度。 一个索引上不同的值越多，这个索引的区分度就越好<br>一个索引上不同 值的个数， 我们称为”基数”</p>
<p>优化器是根据采样来获取基数的。  InnoDB会选择N个数据页， 统计这些页面上的不同值， 得到一个平均值， 然后乘以这个索引的页面数<br>就得到了基数</p>
<p>当变更的数据行超过了1M的时候， 会自动触发重新做一次索引统计</p>
<p>Mysql中， 有两种存储索引统计的方式， 可以通过设置innodb_stats_persistent的值来选择:</p>
<ol>
<li>设置为ON的时候, 表示统计信息会持久化存储， 这时， 默认的N是20， M是10</li>
<li>设置OFF的时候， 表示统计信息只存储在内存中。 这时， 默认的N是8， M是16</li>
</ol>
<p>使用普通索引需要把回表的待机算进去， 优化器会在主键索引中和普通索引中进行比较.        </p>
<h5 id="修复扫描行异常："><a href="#修复扫描行异常：" class="headerlink" title="修复扫描行异常："></a>修复扫描行异常：</h5><ol>
<li>使用 analyze table t 重新统计索引信息</li>
</ol>
<p>索引选择以及修复</p>
<ol>
<li>使用 force index 强行选择一个索引</li>
<li>修改Sql 语句</li>
<li>删除或新增索引</li>
</ol>
<hr>
<h4 id="11-字符串加索引"><a href="#11-字符串加索引" class="headerlink" title="11. 字符串加索引"></a>11. 字符串加索引</h4><p>前缀索引: 使用合适的长度， 可以即节省空间， 又不用额外增加太多的查询成本<br>我们建立索引的时候要注意 “区分度” , 区分度越高， 意味着重复的值越少。<br>可以使用 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>
<p>然后依次可以使用搜索出来的长度值进行比较</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">4</span>)) <span class="keyword">as</span> L4,</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">5</span>)) <span class="keyword">as</span> L5,</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">6</span>)) <span class="keyword">as</span> L6,</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">7</span>)) <span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure>
<p>使用前缀索引会损失区分度， 所以需要设置一个可以接受的损失比例, 比如 L * 0.95 选择最小符合条件的值</p>
<p>对应前缀区分度不是很高的情况</p>
<ol>
<li>第一种方式就是使用倒叙存储</li>
<li>第二种方式就是使用hash字段</li>
</ol>
<hr>
<h3 id="12-MySQL-脏页"><a href="#12-MySQL-脏页" class="headerlink" title="12. MySQL 脏页"></a>12. MySQL 脏页</h3><p>当内存数据跟磁盘数据不一样的时候， 我们就称这个内存页为脏页, 内存数据写入到磁盘之后， 内存和磁盘上面的数据页的内容就一致了， 称为 干净页</p>
<p>不管是脏页还是干净页， 都在内存中</p>
<p>当MySQL突然变慢的时候， 有可能就是在做刷脏页(flush)</p>
<p>写磁盘操作保证了每个数据页有两种情况</p>
<ol>
<li>在内存里存在， 内存里面就是正确的结果， 直接返回</li>
<li>另一种就是内存没有数据， 就可以肯定数据文件上的是正确结果，读入内存中返回</li>
</ol>
<h5 id="四种情况会刷新脏页"><a href="#四种情况会刷新脏页" class="headerlink" title="四种情况会刷新脏页"></a>四种情况会刷新脏页</h5><ol>
<li>InnoDB的redo log 写满了(类比店家的帐本记满了)。 这时系统会停止所有的更新操作， 把 checkpoint 往前推进， redo log 留出空间可以继续写</li>
<li>系统内存不足， 当需要新的页面时候， 就需要淘汰一些旧的页<br>此时如果淘汰的是脏页， 则需要将脏页写入到磁盘</li>
<li>MySQL空闲状态</li>
<li>Mysql正常关机状态</li>
</ol>
<p>3和4 是需要避免的状态<br>第2种状态是 “内存不够用了, 要先将脏页写到磁盘”<br>InnoDB用缓冲池(buffer pool) 管理内存， 缓冲池的内存页有三种状态</p>
<ul>
<li>还没有使用的</li>
<li>使用了并且是干净页</li>
<li>使用了并且是脏页</li>
</ul>
<p>出现下面两种情况, 会明显影响性能</p>
<ul>
<li>一个查询要淘汰的脏页个数太多， 会导致查询的响应时间明显变长</li>
<li>日志写满， 更新全部堵住， 写性能为0</li>
</ul>
<p>InnoDB刷脏页的控制策略</p>
<ul>
<li>要正确告诉InnoDB脏页的控制策略, 以及和这些策略相关的参数</li>
<li>innodb_io_capacity =&gt; 告诉innodb 磁盘能力， 建议是设置成磁盘IOPS<br>控制刷脏页的速度策略</li>
<li>脏页比例 </li>
<li>redo log 写盘速度</li>
</ul>
<p>参数 innodb_max_dirty_pages_pct 是脏页比例上限。 默认值是 75%。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/projects_url">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MYSQL%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">MYSQL架构图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">连接器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.0.2.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">优化器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">执行器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">更新语句执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97-redo-log"><span class="toc-number">2.1.</span> <span class="toc-text">重要的日志模块: redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97-binlog"><span class="toc-number">2.2.</span> <span class="toc-text">重要的日志模块 binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E8%B7%9F-binlog-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">redo log 跟 binlog 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">MySQL 隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">事务隔离的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.1.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.2.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A-%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">4.3.</span> <span class="toc-text">日志系统： 一条SQL更新语句是如何执行的?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql-%E6%9B%B4%E6%96%B0%E7%94%A8%E5%88%B0%E4%BA%86WAL%E6%8A%80%E6%9C%AF-write-Ahead-Logiing-%E5%AE%83%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E6%98%AF%E5%85%88%E5%86%99%E6%97%A5%E5%BF%97%EF%BC%8C-%E5%86%8D%E5%86%99%E7%A3%81%E7%9B%98"><span class="toc-number">4.3.1.</span> <span class="toc-text">Mysql  更新用到了WAL技术(write-Ahead Logiing) , 它的关键点是先写日志， 再写磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="toc-number">4.3.2.</span> <span class="toc-text">redo log(重做日志)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97"><span class="toc-number">4.3.3.</span> <span class="toc-text">binlog(归档日志)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">提交过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">两阶段提交</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID-%E9%9A%94%E7%A6%BB%E6%80%A7-I"><span class="toc-number">4.4.</span> <span class="toc-text">ACID 隔离性(I)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%A6%81%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9"><span class="toc-number">4.5.</span> <span class="toc-text">普通索引和唯一索引要怎么选择?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-MySQL-%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.</span> <span class="toc-text">10 MySQL 选错索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%89%AB%E6%8F%8F%E8%A1%8C%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">修复扫描行异常：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.1.</span> <span class="toc-text">11. 字符串加索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-MySQL-%E8%84%8F%E9%A1%B5"><span class="toc-number">4.7.</span> <span class="toc-text">12. MySQL 脏页</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5%E4%BC%9A%E5%88%B7%E6%96%B0%E8%84%8F%E9%A1%B5"><span class="toc-number">4.7.0.1.</span> <span class="toc-text">四种情况会刷新脏页</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&text=Mysql知识梳理"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&is_video=false&description=Mysql知识梳理"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Mysql知识梳理&body=Check out this article: https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&title=Mysql知识梳理"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&name=Mysql知识梳理&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://dp9166.com/2021/03/06/Mysql%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/&t=Mysql知识梳理"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    Str
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/projects_url">项目</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
